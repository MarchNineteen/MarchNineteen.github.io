---
title: JMM&volatile
date: 2021-06-08
desc:
keywords: JMM volatile
categories: [并发编程]
---
# 现代计算机模型

冯诺依曼计算机模型
![冯诺依曼计算机模型](/uploads/java/concurrent/冯诺依曼计算机模型.png)

现代计算机硬件基本结构
![现代计算机硬件基本结构](/uploads/java/concurrent/现代计算机硬件基本结构.png)

CPU内部结构
![CPU内部结构](/uploads/java/concurrent/CPU内部结构.png)

CPU多核缓存架构
![CPU多核缓存架构](/uploads/java/concurrent/CPU多核缓存架构.png)

缓存一致性协议(MESI)
![缓存一致性协议](/uploads/java/concurrent/缓存一致性协议.png)

## 具体流程：
**主存中存在变量x=1，多cpu多线程读取x（lock的是缓存行，当锁的数据横跨多个缓存行时就会进行总线加锁），copy副本到工作线程，此时所有线程中缓存行的状态
都是S，T1线程想要修改x时，把缓存行设为E，T1修改x之后，其它线程通过总线嗅探机制时刻监听着，其它线程对该缓存行的操作，
发现T1变成M之后，其它线程的变成I，T1对x的操作，等待某一个时间后，刷回主存。其它线程，当发现x被修改之后，会重新去主存中
copy，但是cpu不会等待，从而出现指令重排。**

![具体流程](/uploads/java/concurrent/CPU多核缓存存储结构.png)

# 线程

## 什么是线程

进程是系统分配资源的基本单位，线程是调度CPU的基本单位，一个进程至少包含一个执行线程，
线程寄生在进程当中。每个线程都有一个程序计数器（记录要执行的下一条指令），
一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）

线程分为两类：
用户级线程(User-Level Thread)
内核线线程(Kernel-Level Thread)

用户空间划分：
内核空间
用户空间

![线程深入解读](/uploads/java/concurrent/线程深入解读.png)

## Java线程与内核线程的关系

![Java线程与内核线程的关系](/uploads/java/concurrent/Java线程与内核线程的关系.png)

## Java线程生命状态

![Java线程生命状态](/uploads/java/concurrent/Java线程生命状态.png)

# 并发

## 为什么用到并发

- 充分利用多核CPU的计算能力
- 方便业务拆分，提升应用性能

## 并发产生的问题

- 高并发场景下，导致频繁的上下文切换
- 临界区线程安全问题，容易出现死锁的，产生死锁就会造成系统功能不可用
- 其它

![线程上下文切换过程](/uploads/java/concurrent/线程上下文切换过程.png)

# JMM

JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，
JMM是围绕原子性，有序性、可见性展开。

简单来说：JMM是计算机CPU多核缓存架构java实现，是一种规则。

![JMM模型](/uploads/java/concurrent/JMM模型.png)

## JVM虚拟机规范主内存与工作内存

![JVM虚拟机规范主内存与工作内存](/uploads/java/concurrent/JVM虚拟机规范主内存与工作内存.png)

## Java内存模型与硬件内存架构的关系

JMM模型跟CPU缓存模型结构类似，是基于CPU缓存模型建立起来的，JMM模型是标准化的，
屏蔽掉了底层不同计算机的区别。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，
也就是说Java内存模型对内存的划分对硬件内存并没有任何影响

![Java内存模型与硬件内存架构的关系](/uploads/java/concurrent/Java内存模型与硬件内存架构的关系.png)

## Java内存模型内存交互操作

1.lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态
2.unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3.read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
4.load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
5.use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
6.assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量
7.store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
8.write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，
就需要按顺序地执行store和write操作。但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。

**read和load同时出现，store和write同时出现**

![Java内存模型内存交互操作](/uploads/java/concurrent/Java内存模型内存交互操作.png)

## Java内存模型内存同步规则

![Java内存模型内存同步规则](/uploads/java/concurrent/Java内存模型内存同步规则.png)

# volatile原理与内存语义

volatile是Java虚拟机提供的轻量级的同步机制

volatile语义有如下两个作用
- 可见性：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。
- 有序性：禁止指令重排序优化。

volatile缓存可见性实现原理
- JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。
- 底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效
- 汇编代码查看
XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp

# 可见性&原子性&有序性

并发编程三大特性
- 可见性
- 原子性
- 有序性

volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。

# 有序性&指令重排

java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。

指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。

在编译器与CPU处理器中都能执行指令重排优化操作

![指令重排](/uploads/java/concurrent/指令重排.png)

# 总线风暴--过度使用volatile可能产生的问题


