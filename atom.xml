<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marcher</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://marchnineteen.github.io/"/>
  <updated>2021-07-01T08:01:52.081Z</updated>
  <id>https://marchnineteen.github.io/</id>
  
  <author>
    <name>Marcher</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronized&amp;Lock&amp;AQS</title>
    <link href="https://marchnineteen.github.io/2021/06/08/java/coucurrent/synchronized&amp;Lock&amp;AQS/"/>
    <id>https://marchnineteen.github.io/2021/06/08/java/coucurrent/synchronized&amp;Lock&amp;AQS/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发同步器"><a href="#并发同步器" class="headerlink" title="并发同步器"></a>并发同步器</h1><p>多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况；这种资源可能是：对象、变量、文件等。</p><ul><li>共享：资源可以由多个线程同时访问</li><li>可变：资源可以在其生命周期内被修改</li></ul><p>引出的问题：<br>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问</p><p>加锁目的：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源(同步互斥访问)</p><h1 id="Java锁体系"><a href="#Java锁体系" class="headerlink" title="Java锁体系"></a>Java锁体系</h1><p><img src="/uploads/java/concurrent/Java%E9%94%81%E4%BD%93%E7%B3%BB.png" alt="Java锁体系"></p><blockquote><p><a href="https://juejin.cn/post/6844904110085373966" target="_blank" rel="noopener">https://juejin.cn/post/6844904110085373966</a></p></blockquote><h1 id="synchronized使用与原理"><a href="#synchronized使用与原理" class="headerlink" title="synchronized使用与原理"></a>synchronized使用与原理</h1><p>加锁方式：</p><ul><li>同步实例方法，锁是当前实例对象</li><li>同步类方法，锁是当前类对象</li><li>同步代码块，锁是括号里面的对象</li></ul><p>底层原理:</p><p>JVM内置锁通过synchronized使用，通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与<br>代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低</p><p><img src="/uploads/java/concurrent/synchronized.png" alt="synchronized"></p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>每个对象都有一个自己的Monitor(监视器锁)</p><p>JVM加锁过程：</p><p><img src="/uploads/java/concurrent/synchronized%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B.png" alt="synchronized加锁过程"></p><h2 id="对象内存结构详见jvm"><a href="#对象内存结构详见jvm" class="headerlink" title="对象内存结构详见jvm"></a>对象内存结构<a href="https://marchnineteen.github.io/2018/10/31/java/jvm/jvm(1">详见jvm</a></h2><p>认识对象的内存结构：</p><ul><li>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等</li><li>对象实际数据：即创建对象时，对象中成员变量，方法等</li><li>对齐填充：对象的大小必须是8字节的整数倍</li></ul><p>面试问题：</p><p>实例对象内存中存储在哪？</p><p>如果实例对象存储在堆区时：实例对象内存存在堆区，实例的引用存在栈上，实例的元数据class存在方法区或者元空间</p><p>Object实例对象一定是存在堆区的吗？</p><p>不一定，如果实例对象没有线程逃逸行为</p><p><img src="/uploads/java/concurrent/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="对象的内存结构"></p><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p>以32位JVM中存储内容为例</p><p><img src="/uploads/java/concurrent/MarkWord.png" alt="MarkWord"></p><h2 id="锁优化升级过程"><a href="#锁优化升级过程" class="headerlink" title="锁优化升级过程"></a>锁优化升级过程</h2><p>JDK1.6版本之后对synchronized的实现进行了各种优化，如自旋锁、偏向锁和轻量级锁<br>并默认开启偏向锁<br>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p><p><img src="/uploads/java/concurrent/JVM%E5%86%85%E7%BD%AE%E9%94%81%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="JVM内置锁优化升级过程"></p><p><img src="/uploads/java/concurrent/%E9%94%81%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="锁优化升级过程"></p><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p><img src="/uploads/java/concurrent/lock.png" alt="lock"></p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote><p><a href="https://juejin.cn/post/6844903598984282119" target="_blank" rel="noopener">https://juejin.cn/post/6844903598984282119</a></p></blockquote><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>Java并发编程核心在于java.concurrent.util包<br>而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSynchronizer简称AQS，<br>AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步器。</p><p>AQS具备特性</p><ul><li>阻塞等待队列</li><li>共享/独占</li><li>公平/非公平</li><li>可重入</li><li>允许中断</li></ul><h2 id="并发编程包依赖于AQS的内部实现"><a href="#并发编程包依赖于AQS的内部实现" class="headerlink" title="并发编程包依赖于AQS的内部实现"></a>并发编程包依赖于AQS的内部实现</h2><p>Java.concurrent.util当中同步器的实现如Lock,Latch,Barrier等，都是基于AQS框架实现</p><ul><li>一般通过定义内部类Sync继承AQS</li><li>将同步器所有调用都映射到Sync对应的方法</li></ul><p>AQS框架-管理状态</p><p>AQS内部维护属性volatile int state (32位)</p><ul><li>state表示资源的可用状态</li></ul><p>State三种访问方式</p><ul><li>getState()、setState()、compareAndSetState()</li></ul><p>AQS定义两种资源共享方式</p><ul><li>Exclusive-独占，只有一个线程能执行，如ReentrantLock</li><li>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</li></ul><p>AQS定义两种队列</p><ul><li>同步等待队列</li><li>条件等待队列</li></ul><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列， 是FIFO先入先出线程等待队列，<br>Java中的CLH队列是原CLH队列的一个变种, 线程由原自旋机制改为阻塞机制。</p><p><img src="/uploads/java/concurrent/CLH%E9%98%9F%E5%88%97.png" alt="CLH队列"></p><h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备时 ，这些等待线程才会被唤醒，从而重新争夺锁</p><p><img src="/uploads/java/concurrent/%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><img src="/uploads/java/concurrent/%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁"></p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p><img src="/uploads/java/concurrent/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="非公平锁"></p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p><img src="/uploads/java/concurrent/%E9%87%8D%E5%85%A5%E9%94%81.png" alt="重入锁"></p><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><p><img src="/uploads/java/concurrent/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="不可重入锁"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发同步器&quot;&gt;&lt;a href=&quot;#并发同步器&quot; class=&quot;headerlink&quot; title=&quot;并发同步器&quot;&gt;&lt;/a&gt;并发同步器&lt;/h1&gt;&lt;p&gt;多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况；这种资源可能是：对象、变量、文件等。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JMM&amp;volatile</title>
    <link href="https://marchnineteen.github.io/2021/06/08/java/coucurrent/JMM&amp;volatile/"/>
    <id>https://marchnineteen.github.io/2021/06/08/java/coucurrent/JMM&amp;volatile/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现代计算机模型"><a href="#现代计算机模型" class="headerlink" title="现代计算机模型"></a>现代计算机模型</h1><p>冯诺依曼计算机模型<br><img src="/uploads/java/concurrent/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="冯诺依曼计算机模型"></p><p>现代计算机硬件基本结构<br><img src="/uploads/java/concurrent/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="现代计算机硬件基本结构"></p><p>CPU内部结构<br><img src="/uploads/java/concurrent/CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="CPU内部结构"></p><p>CPU多核缓存架构<br><img src="/uploads/java/concurrent/CPU%E5%A4%9A%E6%A0%B8%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png" alt="CPU多核缓存架构"></p><p>缓存一致性协议(MESI)<br><img src="/uploads/java/concurrent/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.png" alt="缓存一致性协议"></p><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><p><strong>主存中存在变量x=1，多cpu多线程读取x（lock的是缓存行，当锁的数据横跨多个缓存行时就会进行总线加锁），copy副本到工作线程，此时所有线程中缓存行的状态<br>都是S，T1线程想要修改x时，把缓存行设为E，T1修改x之后，其它线程通过总线嗅探机制时刻监听着，其它线程对该缓存行的操作，<br>发现T1变成M之后，其它线程的变成I，T1对x的操作，等待某一个时间后，刷回主存。其它线程，当发现x被修改之后，会重新去主存中<br>copy，但是cpu不会等待，从而出现指令重排。</strong></p><p><img src="/uploads/java/concurrent/CPU%E5%A4%9A%E6%A0%B8%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="具体流程"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>进程是系统分配资源的基本单位，线程是调度CPU的基本单位，一个进程至少包含一个执行线程，<br>线程寄生在进程当中。每个线程都有一个程序计数器（记录要执行的下一条指令），<br>一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）</p><p>线程分为两类：<br>用户级线程(User-Level Thread)<br>内核线线程(Kernel-Level Thread)</p><p>用户空间划分：<br>内核空间<br>用户空间</p><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB.png" alt="线程深入解读"></p><h2 id="Java线程与内核线程的关系"><a href="#Java线程与内核线程的关系" class="headerlink" title="Java线程与内核线程的关系"></a>Java线程与内核线程的关系</h2><p><img src="/uploads/java/concurrent/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Java线程与内核线程的关系"></p><h2 id="Java线程生命状态"><a href="#Java线程生命状态" class="headerlink" title="Java线程生命状态"></a>Java线程生命状态</h2><p><img src="/uploads/java/concurrent/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E7%8A%B6%E6%80%81.png" alt="Java线程生命状态"></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="为什么用到并发"><a href="#为什么用到并发" class="headerlink" title="为什么用到并发"></a>为什么用到并发</h2><ul><li>充分利用多核CPU的计算能力</li><li>方便业务拆分，提升应用性能</li></ul><h2 id="并发产生的问题"><a href="#并发产生的问题" class="headerlink" title="并发产生的问题"></a>并发产生的问题</h2><ul><li>高并发场景下，导致频繁的上下文切换</li><li>临界区线程安全问题，容易出现死锁的，产生死锁就会造成系统功能不可用</li><li>其它</li></ul><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="线程上下文切换过程"></p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<br>JMM是围绕原子性，有序性、可见性展开。</p><p>简单来说：JMM是计算机CPU多核缓存架构java实现，是一种规则。</p><p><img src="/uploads/java/concurrent/JMM%E6%A8%A1%E5%9E%8B.png" alt="JMM模型"></p><h2 id="JVM虚拟机规范主内存与工作内存"><a href="#JVM虚拟机规范主内存与工作内存" class="headerlink" title="JVM虚拟机规范主内存与工作内存"></a>JVM虚拟机规范主内存与工作内存</h2><p><img src="/uploads/java/concurrent/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt="JVM虚拟机规范主内存与工作内存"></p><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p>JMM模型跟CPU缓存模型结构类似，是基于CPU缓存模型建立起来的，JMM模型是标准化的，<br>屏蔽掉了底层不同计算机的区别。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，<br>也就是说Java内存模型对内存的划分对硬件内存并没有任何影响</p><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Java内存模型与硬件内存架构的关系"></p><h2 id="Java内存模型内存交互操作"><a href="#Java内存模型内存交互操作" class="headerlink" title="Java内存模型内存交互操作"></a>Java内存模型内存交互操作</h2><p>1.lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态<br>2.unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定<br>3.read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用<br>4.load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中<br>5.use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎<br>6.assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量<br>7.store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作<br>8.write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p><p>把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，<br>就需要按顺序地执行store和write操作。但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。</p><p><strong>read和load同时出现，store和write同时出现</strong></p><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="Java内存模型内存交互操作"></p><h2 id="Java内存模型内存同步规则"><a href="#Java内存模型内存同步规则" class="headerlink" title="Java内存模型内存同步规则"></a>Java内存模型内存同步规则</h2><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5%E8%A7%84%E5%88%99.png" alt="Java内存模型内存同步规则"></p><h1 id="volatile原理与内存语义"><a href="#volatile原理与内存语义" class="headerlink" title="volatile原理与内存语义"></a>volatile原理与内存语义</h1><p>volatile是Java虚拟机提供的轻量级的同步机制</p><p>volatile语义有如下两个作用</p><ul><li>可见性：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</li><li>有序性：禁止指令重排序优化。</li></ul><p>volatile缓存可见性实现原理</p><ul><li>JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。</li><li>底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效</li><li>汇编代码查看<br>XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</li></ul><h1 id="可见性-amp-原子性-amp-有序性"><a href="#可见性-amp-原子性-amp-有序性" class="headerlink" title="可见性&amp;原子性&amp;有序性"></a>可见性&amp;原子性&amp;有序性</h1><p>并发编程三大特性</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><p>volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p><h1 id="有序性-amp-指令重排"><a href="#有序性-amp-指令重排" class="headerlink" title="有序性&amp;指令重排"></a>有序性&amp;指令重排</h1><p>java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p><p>指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p><p>在编译器与CPU处理器中都能执行指令重排优化操作</p><p><img src="/uploads/java/concurrent/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" alt="指令重排"></p><h1 id="总线风暴–过度使用volatile可能产生的问题"><a href="#总线风暴–过度使用volatile可能产生的问题" class="headerlink" title="总线风暴–过度使用volatile可能产生的问题"></a>总线风暴–过度使用volatile可能产生的问题</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现代计算机模型&quot;&gt;&lt;a href=&quot;#现代计算机模型&quot; class=&quot;headerlink&quot; title=&quot;现代计算机模型&quot;&gt;&lt;/a&gt;现代计算机模型&lt;/h1&gt;&lt;p&gt;冯诺依曼计算机模型&lt;br&gt;&lt;img src=&quot;/uploads/java/concurrent/%E
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>杭州地铁规划2025</title>
    <link href="https://marchnineteen.github.io/2020/04/10/other/hangzhoumetro2025/"/>
    <id>https://marchnineteen.github.io/2020/04/10/other/hangzhoumetro2025/</id>
    <published>2020-04-10T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杭州地铁规划2025"><a href="#杭州地铁规划2025" class="headerlink" title="杭州地铁规划2025"></a>杭州地铁规划2025</h1><p><img src="/uploads/other/%E6%9D%AD%E5%B7%9E%E5%9C%B0%E9%93%81%E8%A7%84%E5%88%922025.jpg" alt="杭州地铁规划2025.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;杭州地铁规划2025&quot;&gt;&lt;a href=&quot;#杭州地铁规划2025&quot; class=&quot;headerlink&quot; title=&quot;杭州地铁规划2025&quot;&gt;&lt;/a&gt;杭州地铁规划2025&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/uploads/other/%E6%9D%AD%E5%
      
    
    </summary>
    
    
      <category term="other" scheme="https://marchnineteen.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>java 1.8  steam流操作</title>
    <link href="https://marchnineteen.github.io/2020/01/11/java/javase/streamApiAction/"/>
    <id>https://marchnineteen.github.io/2020/01/11/java/javase/streamApiAction/</id>
    <published>2020-01-11T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/java8/StreamApiAction.java" target="_blank" rel="noopener">相应源码地址</a></p><h2 id="流操作类型"><a href="#流操作类型" class="headerlink" title="流操作类型"></a>流操作类型</h2><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>目的是打开一个流，做出一些操作或者映射后，会返回一个新的流交给下个操作。lazy的，在调用方式时并没有真正执行。</p><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>在执行这个操作后，流被使用，在出现终止操作时才会调用之前的所有方法。</p><h3 id="short-circuiting"><a href="#short-circuiting" class="headerlink" title="short-circuiting"></a>short-circuiting</h3><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。<br>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p><h2 id="具体流操作"><a href="#具体流操作" class="headerlink" title="具体流操作"></a>具体流操作</h2><h3 id="中间操作-1"><a href="#中间操作-1" class="headerlink" title="中间操作"></a>中间操作</h3><ul><li>map (mapToInt, flatMap 等)</li></ul><p>把input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><p>map一对一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;list中数的平方</span><br><span class="line">list.stream().map(v -&gt; v * v)</span><br></pre></td></tr></table></figure><p>flatMap一对多 多对多 映射,把流扁平化，多个流转化成流里所有元素的单个流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">List&lt;Integer&gt; list2 &#x3D; Arrays.asList(6, 7, 8, 9, 10);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; allList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">allList.add(list1);</span><br><span class="line">allList.add(list2);</span><br><span class="line">        </span><br><span class="line">allList.stream().flatMap(v -&gt; v.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>filter </li></ul><p>过滤,对元素进行某种条件过滤，留下符合的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 留下偶数</span><br><span class="line">list.stream().filter(v -&gt; v % 2 &#x3D;&#x3D; 0).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>distinct </li></ul><p>去重，不接收方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>sorted</li></ul><p>排序，接受一个Comparator，或者默认顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted()</span><br><span class="line">list.stream().sorted((o1, o2) -&gt; -1)</span><br></pre></td></tr></table></figure><ul><li>peek</li></ul><p>peek 对每个元素执行操作并返回一个新的 Stream。类似foreach，foreach是终止操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &#x3D; list.stream().peek(System.out::println).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><ul><li>limit</li></ul><p>返回 Stream 的前面 n 个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().limit(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>skip</li></ul><p>扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>parallel</li></ul><p>转行成并行流，进行多线程操作，顺序会改变。可以使用forEachOrdered，固定顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.stream().parallel().forEach(System.out::println);</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><ul><li>sequential</li></ul><p>并行流转为串行流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.parallelStream().forEach(System.out::println);</span><br><span class="line">list.parallelStream().sequential().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>unordered</li></ul><p><strong>消除了必须保持有序的流的约束</strong>,返回一个无序的等效的Stream，可能返回的是Stream本身，因为该Stream已经是无序的，或者该Stream的底层状态被修改为了无序.<br>一般用于并行的时候。例如TreeSet，或者流操作中指定顺序，会取消排序和指定顺序无效。</p><h3 id="终止操作-1"><a href="#终止操作-1" class="headerlink" title="终止操作"></a>终止操作</h3><ul><li>forEach</li></ul><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><ul><li><p>forEachOrdered</p></li><li><p>toArray</p></li><li><p>reduce</p></li></ul><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。<br>从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p><p>注意：没有起始值，返回对象为Optional</p><ul><li>collect</li></ul><p>两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">                  BiConsumer&lt;R, R&gt; combiner);</span><br><span class="line">                  </span><br><span class="line">IntStream i &#x3D; IntStream.of(6,5,7,1, 2, 3, 3);</span><br><span class="line">  List&lt;Integer&gt; v &#x3D; i</span><br><span class="line">      .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</span><br><span class="line">  </span><br><span class="line">  System.out.println(v);</span><br><span class="line"></span><br><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br></pre></td></tr></table></figure><p>Collector在后面重点讲解</p><ul><li><p>min</p></li><li><p>max</p></li><li><p>count</p></li><li><p>anyMatch</p></li><li><p>allMatch</p></li><li><p>noneMatch</p></li><li><p>findFirst</p></li><li><p>findAny</p></li><li><p>iterator</p></li></ul><h3 id="Short-circuiting"><a href="#Short-circuiting" class="headerlink" title="Short-circuiting"></a>Short-circuiting</h3><ul><li><p>anyMatch</p></li><li><p>allMatch </p></li><li><p>noneMatch</p></li><li><p>findFirst </p></li><li><p>findAny </p></li><li><p>limit</p></li></ul><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p><ul><li>类型归纳 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collectors.toList();</span><br><span class="line">Collectors.toMap();</span><br><span class="line">Collectors.toSet();</span><br><span class="line">Collectors.toCollection();</span><br><span class="line">Collectors.toConcurrentMap();</span><br></pre></td></tr></table></figure><ul><li>joining</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>, <span class="string">"ee"</span>);</span><br><span class="line">String s = strList.stream().collect(Collectors.joining());</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// 逗号连接</span></span><br><span class="line">s = strList.stream().collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// 逗号连接</span></span><br><span class="line">s = strList.stream().collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br><span class="line">System.out.println(s);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- collectingAndThen</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">s = strList.stream().collect(Collectors.collectingAndThen(Collectors.joining(<span class="string">","</span>), String::toUpperCase));</span><br></pre></td></tr></table></figure><ul><li>groupingBy groupingByConcurrent</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = strList.stream().collect(Collectors.groupingBy(String::length));</span><br><span class="line">map.keySet().forEach(v -&gt; map.get(v).forEach(System.out::println));</span><br><span class="line">    </span><br><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map1 = strList.stream().collect(Collectors.groupingBy(String::length, Collectors.toSet();</span><br></pre></td></tr></table></figure><ul><li>partitioningBy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; mapBoolean = list.stream().collect(Collectors.partitioningBy(v -&gt; v % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">mapBoolean.keySet().forEach(v -&gt; mapBoolean.get(v).forEach(System.out::println));</span><br></pre></td></tr></table></figure><ul><li>summingInt/Double/Long summarizingInt/Double/Long</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/java8/StreamApiA
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="https://marchnineteen.github.io/categories/JavaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>秒杀场景</title>
    <link href="https://marchnineteen.github.io/2019/12/20/active/miaosha/"/>
    <id>https://marchnineteen.github.io/2019/12/20/active/miaosha/</id>
    <published>2019-12-20T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秒杀场景可能遇到的问题（用户流程角度）"><a href="#秒杀场景可能遇到的问题（用户流程角度）" class="headerlink" title="秒杀场景可能遇到的问题（用户流程角度）"></a>秒杀场景可能遇到的问题（用户流程角度）</h1><ul><li><p>问题一.即将到秒杀时间，同时请求网页过多，打开网页速度慢</p></li><li><p>问题二.进入页面后，未到秒杀时间，用户一直点击购买按钮，一直发起请求</p></li><li><p>问题三.用户拿到接口地址，恶意请求（用脚本）</p></li><li><p>问题四.超卖现象</p></li><li><p>问题五.数据库请求过多，数据库奔溃</p></li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><ul><li><p>针对于动态页面（jsp，ftl）可以把整个页面存储在redis中，避免页面渲染。</p></li><li><p>前后端分离项目，页面单独部署，使用cdn加速，资源静态</p></li><li><p>打开网页速度慢，除了页面的原因外，后台请求返回慢也有很大的关系，简单说就是后台高并发能力不足，一遇到此类场景，cpu，内存飚升，程序响应慢。单台tomcat并发量不足，可以集群部署然后使用nginx做负载均衡，恶意请求也可以在此拦截。</p></li><li><p>后台对请求限流</p></li></ul><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><ul><li>页面按钮控制，未到时间按钮不能点击，需要页面定时请求后台获取最新的北京时间，不能以页面本地时间为准</li><li>在用户点击过后，再把按钮设置无效，防止无效重复点击</li></ul><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>接口地址动态化，通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过</p><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><h3 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h3><p>典型的读多先少场景，使用mysql等nosql，把库存存入redis中，进行库存预热。通过三级缓冲保证数据库压力，本地内存标记，库存修改在redis中进行预存，接着通过mq进行异步下单，处理数据库。若下单成功，页面轮询接口返回订单处理状态。</p><h3 id="解决超卖方案"><a href="#解决超卖方案" class="headerlink" title="解决超卖方案"></a>解决超卖方案</h3><ul><li>防止数据库内存为0，在修改时进行库存判断，大于0才更新。</li><li>用户id与商品id建立唯一所以，防止同一用户重复购买同一件商品。</li><li>实现乐观锁，商品信息中年增加version字段。每次更新时version+1，更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试。</li></ul><p>一整套解决方案</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/16/16e72d24415cb009?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="秒杀"></p><h2 id="产生更多的问题"><a href="#产生更多的问题" class="headerlink" title="产生更多的问题"></a>产生更多的问题</h2><ul><li>redis集群，数据同步,分布式锁等</li><li>mq高可用</li><li>限流&amp;降级&amp;熔断&amp;隔离</li><li>分布式服务，事务处理。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秒杀场景可能遇到的问题（用户流程角度）&quot;&gt;&lt;a href=&quot;#秒杀场景可能遇到的问题（用户流程角度）&quot; class=&quot;headerlink&quot; title=&quot;秒杀场景可能遇到的问题（用户流程角度）&quot;&gt;&lt;/a&gt;秒杀场景可能遇到的问题（用户流程角度）&lt;/h1&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="active" scheme="https://marchnineteen.github.io/categories/active/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Bean 生命周期</title>
    <link href="https://marchnineteen.github.io/2019/12/06/spring/beanLifeCycle/"/>
    <id>https://marchnineteen.github.io/2019/12/06/spring/beanLifeCycle/</id>
    <published>2019-12-06T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="/uploads/spring/springBeanLifeCycle.png" alt="生命周期"></p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><img src="/uploads/spring/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fspringbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="单例模式生命周期"></p><h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h1><p>需求主动调用才会创建对象，原因见下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LifeCycle lifeCycle &#x3D; (LifeCycle) applicationContext.getBean(&quot;lifeCycle&quot;);</span><br></pre></td></tr></table></figure><p><img src="/uploads/spring/%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8Fspringbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="多例模式生命周期"></p><h1 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h1><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><p>bean在单例模式下，spring容器启动时解析xml文件发现该bean标签后，直接创建该bean对象存入内部map中保存，<br>此后无论调用多少次getBean()获取该bean都是从map中获取该对象返回，一直是一个对象。<br>此对象一直被spring容器持有，直到容器推出时，随着容器的退出对象被销毁。</p><h2 id="多例模式-1"><a href="#多例模式-1" class="headerlink" title="多例模式"></a>多例模式</h2><p>bean在多例模式下，spring容器启动时解析xml发下该bean标签后，只是将该bean进行管理，并不会创建对象，<br>此后每层使用getBean()获取该bean时，spring都会重新创建该对象返回，每层都是一个新的对象。<br>这个对象spring容器并不会持有，什么时候销毁却决于该对象的用户自己什么时候销毁该对象。</p><h1 id="相应测试源码"><a href="#相应测试源码" class="headerlink" title="相应测试源码"></a><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/spring/bean/LifeCycle.java" target="_blank" rel="noopener">相应测试源码</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/uploads/spring/springBeanLifeCycle.png&quot; alt=&quot;生命周期&quot;&gt;
      
    
    </summary>
    
    
      <category term="spring" scheme="https://marchnineteen.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring 加载XML文件的六种方式</title>
    <link href="https://marchnineteen.github.io/2019/12/06/spring/springLoadXml/"/>
    <id>https://marchnineteen.github.io/2019/12/06/spring/springLoadXml/</id>
    <published>2019-12-06T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-XmlBeanFactory-引用资源"><a href="#一-XmlBeanFactory-引用资源" class="headerlink" title="一: XmlBeanFactory 引用资源"></a>一: XmlBeanFactory 引用资源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource resource &#x3D; new ClassPathResource(&quot;appcontext.xml&quot;);</span><br><span class="line">BeanFactory factory &#x3D; new XmlBeanFactory(resource);</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) factory.getBean(&quot;baseEntity1&quot;);</span><br><span class="line">System.out.println(&quot;XmlBeanFactory 获取 bean ：&quot; + entity.getId());</span><br></pre></td></tr></table></figure><h1 id="二-ClassPathXmlApplicationContext-编译路径"><a href="#二-ClassPathXmlApplicationContext-编译路径" class="headerlink" title="二: ClassPathXmlApplicationContext  编译路径"></a>二: ClassPathXmlApplicationContext  编译路径</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个文件</span><br><span class="line">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:appcontext.xml&quot;);</span><br><span class="line">&#x2F;&#x2F; 多个文件</span><br><span class="line">ApplicationContext multiApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:appcontext.xml&quot;, &quot;classpath:appcontext2.xml&quot;);</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) applicationContext.getBean(&quot;baseEntity&quot;);</span><br><span class="line"></span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) multiApplicationContext.getBean(&quot;baseEntity2&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean2 ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure><h1 id="三-用文件系统的路径"><a href="#三-用文件系统的路径" class="headerlink" title="三: 用文件系统的路径"></a>三: 用文件系统的路径</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; classPath</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext &#x3D; new FileSystemXmlApplicationContext(&quot;classpath:appcontext.xml&quot;);</span><br><span class="line">&#x2F;&#x2F; 文件系统</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext2 &#x3D; new FileSystemXmlApplicationContext(&quot;spring-example-test&#x2F;src&#x2F;main&#x2F;resources&#x2F;appcontext.xml&quot;);</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext3 &#x3D; new FileSystemXmlApplicationContext(&quot;file:E:\\marcher\\spring-example\\spring-example-test\\src\\main\\resources&#x2F;appcontext.xml&quot;);</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext4 &#x3D; new FileSystemXmlApplicationContext(&quot;E:\\marcher\\spring-example\\spring-example-test\\src\\main\\resources&#x2F;appcontext.xml&quot;);</span><br><span class="line"></span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) fileSystemXmlApplicationContext.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) fileSystemXmlApplicationContext2.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity3 &#x3D; (BaseEntity) fileSystemXmlApplicationContext3.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity4 &#x3D; (BaseEntity) fileSystemXmlApplicationContext4.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure><h1 id="四-XmlWebApplicationContext是专为Web工程定制的。"><a href="#四-XmlWebApplicationContext是专为Web工程定制的。" class="headerlink" title="四: XmlWebApplicationContext是专为Web工程定制的。"></a>四: XmlWebApplicationContext是专为Web工程定制的。</h1><p>ServletContext servletContext = request.getSession().getServletContext();<br>ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext ); </p><h1 id="五-使用BeanFactory"><a href="#五-使用BeanFactory" class="headerlink" title="五: 使用BeanFactory"></a>五: 使用BeanFactory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionRegistry reg &#x3D; new DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader &#x3D; new XmlBeanDefinitionReader(reg);</span><br><span class="line">reader.loadBeanDefinitions(new ClassPathResource(&quot;appcontext.xml&quot;));</span><br><span class="line">reader.loadBeanDefinitions(new ClassPathResource(&quot;appcontext2.xml&quot;));</span><br><span class="line">BeanFactory bf &#x3D; (BeanFactory) reg;</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) bf.getBean(&quot;baseEntity&quot;);</span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) bf.getBean(&quot;baseEntity2&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure><h1 id="六：Web-应用启动时加载多个配置文件"><a href="#六：Web-应用启动时加载多个配置文件" class="headerlink" title="六：Web 应用启动时加载多个配置文件"></a>六：Web 应用启动时加载多个配置文件</h1><p>通过ContextLoaderListener 也可加载多个配置文件，在web.xml文件中利用<br><context-pararn>元素来指定多个配置文件位置，其配置如下: </context-pararn></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;  </span><br><span class="line">    &lt;!-- Context Configuration locations for Spring XML files --&gt;  </span><br><span class="line">       &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;  </span><br><span class="line">       &lt;param-value&gt;  </span><br><span class="line">       .&#x2F;WEB-INF&#x2F;**&#x2F;Appserver-resources.xml,  </span><br><span class="line">       classpath:config&#x2F;aer&#x2F;aerContext.xml,  </span><br><span class="line">       classpath:org&#x2F;codehaus&#x2F;xfire&#x2F;spring&#x2F;xfire.xml,  </span><br><span class="line">       .&#x2F;WEB-INF&#x2F;**&#x2F;*.spring.xml  </span><br><span class="line">       &lt;&#x2F;param-value&gt;  </span><br><span class="line">   &lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure><p>这个方法加载配置文件的前提是已经知道配置文件在哪里，虽然可以利用“*”通配符，但灵活度有限。 </p><h1 id="获取配套代码"><a href="#获取配套代码" class="headerlink" title="获取配套代码"></a><a href="https://github.com/MarchNineteen/spring-example/tree/master/spring-example-test/src/main/java/com/wyb/test/spring/loadXml" target="_blank" rel="noopener">获取配套代码</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-XmlBeanFactory-引用资源&quot;&gt;&lt;a href=&quot;#一-XmlBeanFactory-引用资源&quot; class=&quot;headerlink&quot; title=&quot;一: XmlBeanFactory 引用资源&quot;&gt;&lt;/a&gt;一: XmlBeanFactory 引用资源
      
    
    </summary>
    
    
      <category term="spring" scheme="https://marchnineteen.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>springmvc整合swagger（非springboot项目）</title>
    <link href="https://marchnineteen.github.io/2019/11/27/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/springMVC&amp;swagger/"/>
    <id>https://marchnineteen.github.io/2019/11/27/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/springMVC&amp;swagger/</id>
    <published>2019-11-27T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h1><p>公司原来的项目是struts2，然后想要改成前后端分离项目，又不想完全抛去原来的一些东西，选择了单独的springmvc，没有使用springboot，这就开启了我的难受之旅。</p><h1 id="需要依赖"><a href="#需要依赖" class="headerlink" title="需要依赖"></a>需要依赖</h1><p>万万没想到啊，还不是maven项目，jar包需要自己去探索到底需要哪些jar包，然后还得避免jar包冲突，我太南了…<br>过程中guava库需要升级 jackson库必须存在</p><p>最后根据maven项目的所引入的依赖分析，然后自己测试，需要jar包如下：</p><p><img src="/uploads/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/swagger%E6%89%80%E9%9C%80jar.jpg" alt="swagger所需jar"></p><p><a href="/uploads/日常问题记录/swagger.rar">下载</a></p><h1 id="过程遇到的问题"><a href="#过程遇到的问题" class="headerlink" title="过程遇到的问题"></a>过程遇到的问题</h1><p>上述过程完成后，好不容易项目启动不报错了，但是访问swagger-ui.html，会出现弹框提示错误，这个错误网上随便一搜就会知道是swagger-ui的页面没有映射出来，需要加个静态资源映射。<br>但是并没有那么简单。</p><p>网上搜索大部分搜索出来的都是在xml文件中添加swagger文件的映射，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources mapping&#x3D;&quot;swagger-ui.html&quot; location&#x3D;&quot;classpath*:&#x2F;META-INF&#x2F;resources&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">&lt;mvc:resources mapping&#x3D;&quot;webjars&#x2F;**&quot; location&#x3D;&quot;classpath*:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>但是在我的工程中没有效果，我也不知道为什么。</p><p>解决办法一：</p><p>由于项目还是采用web.xml格式配置，dispatcherServlet需拦截所有请求，如果加*.htm这种类型，生成的文档接口也必须手动修改访问路径，因为swagger是根据mapping去生成请求路径的。</p><p>这样配置之后静态资源也会访问springMVC的servlet，这是我们不需要的，所以我们需要在springmvc.xml添加<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>,添加一个默认servlet，会自动过滤静态资源请求。</p><p>解决办法二：</p><p>去swagger的网站下载zip包，把dist文件目录copy至自己的页面下，修改index.htm文件中的url地址, /v2/api-docs即为swagger访问数据的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">  &#x2F;&#x2F; Begin Swagger UI call region</span><br><span class="line">  const ui &#x3D; SwaggerUIBundle(&#123;</span><br><span class="line">    &#x2F;&#x2F; url: &quot;https:&#x2F;&#x2F;petstore.swagger.io&#x2F;v2&#x2F;swagger.json&quot;,</span><br><span class="line">    url: &quot;http:&#x2F;&#x2F;xx.xx.xx&#x2F;v2&#x2F;api-docs&quot;,</span><br><span class="line">    dom_id: &#39;#swagger-ui&#39;,</span><br><span class="line">    deepLinking: true,</span><br><span class="line">    presets: [</span><br><span class="line">      SwaggerUIBundle.presets.apis,</span><br><span class="line">      SwaggerUIStandalonePreset</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">      SwaggerUIBundle.plugins.DownloadUrl</span><br><span class="line">    ],</span><br><span class="line">    layout: &quot;StandaloneLayout&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; End Swagger UI call region</span><br><span class="line"></span><br><span class="line">  window.ui &#x3D; ui</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样添加之后，我们需要去直接访问自己的页面地址，而不是访问swagger-ui.html，例如/swagger/index.html。<br>如果采用<em>.htm或者</em>.do这种方式，可能会出现页面访问得到的，提示/v2/api-docs接口无法请求。解决方案是配置把swagger或者数据的接口置入dispatcherServlet中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringmvcDispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;v2&#x2F;api-docs&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目需求&quot;&gt;&lt;a href=&quot;#项目需求&quot; class=&quot;headerlink&quot; title=&quot;项目需求&quot;&gt;&lt;/a&gt;项目需求&lt;/h1&gt;&lt;p&gt;公司原来的项目是struts2，然后想要改成前后端分离项目，又不想完全抛去原来的一些东西，选择了单独的springmvc，没
      
    
    </summary>
    
    
      <category term="日常问题记录" scheme="https://marchnineteen.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://marchnineteen.github.io/2019/10/25/cache/redis/"/>
    <id>https://marchnineteen.github.io/2019/10/25/cache/redis/</id>
    <published>2019-10-25T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述（什么是redis）"><a href="#一、概述（什么是redis）" class="headerlink" title="一、概述（什么是redis）"></a>一、概述（什么是redis）</h1><p>redis是开源免费的key-value内存数据库。</p><p>redis可以存储5种数据类型。键只支持string，值支持string，list，map，set，zset五种。</p><p>redis支持数据持久化，使用复制来扩展读性能，使用分片来扩展写性能。</p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><table><thead><tr><th align="center">数据类型</th><th align="center">可以存储的值</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center">字符串、整数或者浮点数</td><td align="center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td align="center">LIST</td><td align="center">列表</td><td align="center">从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td></tr><tr><td align="center">SET</td><td align="center">无序集合</td><td align="center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td align="center">HASH</td><td align="center">包含键值对的无序散列表</td><td align="center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td align="center">ZSET</td><td align="center">有序集合</td><td align="center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h1 id="四、redis应用场景"><a href="#四、redis应用场景" class="headerlink" title="四、redis应用场景"></a>四、redis应用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>利用string类型可以存储整数和浮点数，进行自增自减操作。</p><h2 id="缓存（用的最多的场景）"><a href="#缓存（用的最多的场景）" class="headerlink" title="缓存（用的最多的场景）"></a>缓存（用的最多的场景）</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><p>将不经常改变的数据存入缓存，访问频繁访问数据库。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-cache/src/test/java/com/wyb/cache/RedisMqTests.java" target="_blank" rel="noopener">redis 实现 点对点  发布/订阅 消息队列 </a></p><h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h1 id="五、数据淘汰策略"><a href="#五、数据淘汰策略" class="headerlink" title="五、数据淘汰策略"></a>五、数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th align="center">策略</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">volatile-lru</td><td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">volatile-ttl</td><td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td align="center">volatile-random</td><td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td align="center">allkeys-lru</td><td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">allkeys-random</td><td align="center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td align="center">noeviction</td><td align="center">禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h1 id="六、持久化"><a href="#六、持久化" class="headerlink" title="六、持久化"></a>六、持久化</h1><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th align="center">选项</th><th align="center">同步频率</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">每个写命令都同步</td></tr><tr><td align="center">everysec</td><td align="center">每秒同步一次</td></tr><tr><td align="center">no</td><td align="center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h1 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h1><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h1 id="八、复制"><a href="#八、复制" class="headerlink" title="八、复制"></a>八、复制</h1><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol><li><p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p></li><li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p></li><li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p></li></ol><h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><h1 id="九、Sentinel"><a href="#九、Sentinel" class="headerlink" title="九、Sentinel"></a>九、Sentinel</h1><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h1 id="十、分片"><a href="#十、分片" class="headerlink" title="十、分片"></a>十、分片</h1><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述（什么是redis）&quot;&gt;&lt;a href=&quot;#一、概述（什么是redis）&quot; class=&quot;headerlink&quot; title=&quot;一、概述（什么是redis）&quot;&gt;&lt;/a&gt;一、概述（什么是redis）&lt;/h1&gt;&lt;p&gt;redis是开源免费的key-value内存
      
    
    </summary>
    
    
      <category term="cache" scheme="https://marchnineteen.github.io/categories/cache/"/>
    
    
  </entry>
  
  <entry>
    <title>缓存概要</title>
    <link href="https://marchnineteen.github.io/2019/10/25/cache/index/"/>
    <id>https://marchnineteen.github.io/2019/10/25/cache/index/</id>
    <published>2019-10-25T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、缓存特征"><a href="#一、缓存特征" class="headerlink" title="一、缓存特征"></a>一、缓存特征</h1><h2 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h2><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h2 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h2><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><ul><li><p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p></li><li><p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p></li><li><p>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</p></li></ul><h1 id="二、LRU"><a href="#二、LRU" class="headerlink" title="二、LRU"></a>二、LRU</h1><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p><p>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。<br>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</p><p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/algorithms/cache/LRU.java" target="_blank" rel="noopener">LRU实现</a></p><h1 id="三、CDN"><a href="#三、CDN" class="headerlink" title="三、CDN"></a>三、CDN</h1><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><h1 id="四、缓存问题"><a href="#四、缓存问题" class="headerlink" title="四、缓存问题"></a>四、缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指对某一个一定不存在的数据进行请求，该请求会将穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据</li><li>对这类请求进行过滤</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><h2 id="缓存-“无底洞”-现象"><a href="#缓存-“无底洞”-现象" class="headerlink" title="缓存 “无底洞” 现象"></a>缓存 “无底洞” 现象</h2><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p><p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p><p>解决方案：</p><ul><li>优化批量数据操作命令；</li><li>减少网络通信次数；</li><li>降低接入成本，使用长连接 / 连接池，NIO 等。</li></ul><h1 id="五、数据分布"><a href="#五、数据分布" class="headerlink" title="五、数据分布"></a>五、数据分布</h1><h2 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><h2 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h1 id="六、一致性哈希"><a href="#六、一致性哈希" class="headerlink" title="六、一致性哈希"></a>六、一致性哈希</h1><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><p><img src="/uploads/cache/%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="一致性hash原理图"></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><img src="/uploads/cache/%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="一致性hash增加节点示意图"></p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、缓存特征&quot;&gt;&lt;a href=&quot;#一、缓存特征&quot; class=&quot;headerlink&quot; title=&quot;一、缓存特征&quot;&gt;&lt;/a&gt;一、缓存特征&lt;/h1&gt;&lt;h2 id=&quot;命中率&quot;&gt;&lt;a href=&quot;#命中率&quot; class=&quot;headerlink&quot; title=&quot;命中率
      
    
    </summary>
    
    
      <category term="cache" scheme="https://marchnineteen.github.io/categories/cache/"/>
    
    
  </entry>
  
  <entry>
    <title>webXml和spring初始化顺序问题</title>
    <link href="https://marchnineteen.github.io/2019/10/17/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/webXml%E5%92%8Cspring%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://marchnineteen.github.io/2019/10/17/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/webXml%E5%92%8Cspring%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</id>
    <published>2019-10-17T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h1><p>同事想要在项目初始化完成后，开启线程池执行业务逻辑的代码，其中需要注入spring的bean，他想到使用servlet的listener，但是无法在listener中无法直接通过@Resource注解获取实例。</p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>在tomcat容器中，listener，filter，servlet等都不是交给spring容器管理，两者环境不一致当然就获取不到了。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>如果需要在tomcat等web容器环境中获取spring实例需要获取ServletContext，通过webContext去获取springIOC容器从而获取spring实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ServletContext,是一个全局的储存信息的空间，服务器开始，其就存在，服务器关闭，其才释放。request，一个用户可有多个；session，一个用户一个；而servletContext，所有用户共用一个。</span><br><span class="line">&#x2F;&#x2F;所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        WebApplicationContext springContext &#x3D; WebApplicationContextUtils.getWebApplicationContext(servletContextEvent.getServletContext());</span><br><span class="line">        Init init &#x3D; (Init) springContext.getBean(&quot;Init&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(init);</span><br><span class="line">        System.out.println(&quot;listener init&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h1><h2 id="web-xml文件中各个节点参数的启动顺序"><a href="#web-xml文件中各个节点参数的启动顺序" class="headerlink" title="web.xml文件中各个节点参数的启动顺序"></a>web.xml文件中各个节点参数的启动顺序</h2><p>可以明确的是初始化顺序context-param -&gt; listener-&gt; filter -&gt; servlet。</p><p>在代码中分别自定义listener，filter，spring bean（Init）。启动项目可以看出先打印 listener init,再打印filter init。</p><p>那么spring容器的bean呢，在什么时候会进行初始化。新建Init类实现InitializingBean，然后在xml中配置该bean，这样spring容器初始化是会去执行afterPropertiesSet方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;InitializingBean&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建完java文件后，咱们先来看看 web.xml。</p><p>一般springIOC容器在context-param进行初始化，<strong>此时spring就已经在初始化xml文件中的实例了</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在web.xml中通过contextConfigLocation配置spring，contextConfigLocation--&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;</span><br><span class="line">            classpath:spring-context.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure><p>spring的xml其实也可以放在其它地方进行加载，比如说listener，servlet中，例如springMVC的xml文件，会配置在servlet中，进行路由转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 请求转发器 --&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>如若此时在contextConfigLocation下增加classpath:spring-context.xml，spring同样也会去初始化配置文件。所以可以得出结论，springIOC环境的<br>初始化与web context的初始化顺序无直接关联。</p><p>那么问题来了，在listener，filter中获取WebApplicationContext可以获得spring bean吗？</p><p>我们先把spring-context.xml放在context-param中，让它在lister之前进行spring初始化，看看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   修改xml文件</span><br><span class="line">   &lt;context-param&gt;</span><br><span class="line">       &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">       &lt;param-value&gt;</span><br><span class="line">           classpath:spring-context.xml</span><br><span class="line">       &lt;&#x2F;param-value&gt;</span><br><span class="line">   &lt;&#x2F;context-param&gt;</span><br><span class="line">   </span><br><span class="line">修改自定义CustomListener   </span><br><span class="line">@Override</span><br><span class="line">   public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">       WebApplicationContext springContext &#x3D; WebApplicationContextUtils.getWebApplicationContext(servletContextEvent.getServletContext());</span><br><span class="line">       Init init &#x3D; (Init) springContext.getBean(&quot;init&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(init);</span><br><span class="line">       System.out.println(&quot;listener init&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此时InitializingBean最先打印出来，说明其在listener，filter之前执行了。<br>控制台输出 com.wyb.web.config.Init@e082c17，说明在listen之前，spring的Context已经初始化，可以获取到bean，那么我们把spring-context.xml<br>放在servlet中去初始化，即在listener之后初始化会怎么样呢？</p><p>修改web.xml代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:spring-mvc.xml,classpath:spring-context.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>此时InitializingBean最后打印，说明其在listener，filter之后执行了。<br>CustomListener抛出NoSuchBeanDefinitionException异常，即无法获得该实例，由此得出结论，spring bean的初始化顺序由配置文件在web.xml中什么时候加载有关，与listener，filter无直接关系。<br><strong>若listener想获得spring bean，该bean需要在listener之前<br>进行初始化</strong>。</p><p>两个spring bean之间进行相互注入依赖，则要看xml文件在web.xml进行加载的顺序。绝对了spring bean初始化的顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题产生&quot;&gt;&lt;a href=&quot;#问题产生&quot; class=&quot;headerlink&quot; title=&quot;问题产生&quot;&gt;&lt;/a&gt;问题产生&lt;/h1&gt;&lt;p&gt;同事想要在项目初始化完成后，开启线程池执行业务逻辑的代码，其中需要注入spring的bean，他想到使用servlet的li
      
    
    </summary>
    
    
      <category term="日常问题记录" scheme="https://marchnineteen.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>git常用指令</title>
    <link href="https://marchnineteen.github.io/2019/08/27/tool/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://marchnineteen.github.io/2019/08/27/tool/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2019-08-27T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h1><ul><li>版本回退：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log (git log --pretty&#x3D;oneline) 查看提交日志</span><br><span class="line">git log --graph --pretty&#x3D;oneline --abbrev-commit 简化查看日志</span><br><span class="line">git reset --hard commitid(HEAD^ HEAD表示当前版本 ^表示上个版本 以此类推,也可以使用~num,num表示几个^) (windows命令行下需要git reset --hard &quot;HEAD^&quot; ) </span><br><span class="line">git reflog 查看命令历史</span><br></pre></td></tr></table></figure><ul><li>管理修改：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add xx 把文件添加到版本库</span><br><span class="line">git status 查看当前版本库状态</span><br><span class="line">git commit -m &quot;msg&quot; 提交修改 -m表示提交注释 ps:若使用命令行提交，每次commit都需add</span><br><span class="line">git diff </span><br><span class="line">git diff HEAD -- xx.file 查看工作区和版本库里面最新版本的区别 (HEAD^ 与版本回退同理)</span><br></pre></td></tr></table></figure><ul><li>撤销修改：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- xx 把文件在工作区的修改全部撤销。第一种情况修改后未被放入暂存区，撤销修改与版本库一致，第二种已经添加到了暂存区，又作了修改，撤销修改回到add时的状态。让这个文件回到最近一次git commit或git add时的状态</span><br><span class="line"></span><br><span class="line">git reset HEAD &lt;file&gt; 把暂存区的修改回退到工作区,适用于add未commit</span><br></pre></td></tr></table></figure><ul><li>删除文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 用于删除一个文件</span><br></pre></td></tr></table></figure><ul><li>取消文件跟踪：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached xx.txt 删除readme1.txt的跟踪，并保留在本地。之后git commit </span><br><span class="line"></span><br><span class="line">git rm --f xx.txt 删除readme1.txt的跟踪，并且删除本地文件。之后git commit</span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul><li>添加远程库：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xx.git 添加远程仓库地址</span><br><span class="line">git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br><span class="line">git push origin master推送最新修改</span><br></pre></td></tr></table></figure><ul><li>从远程库克隆：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xx.git</span><br></pre></td></tr></table></figure><ul><li>多人协作：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote -v 查看远程库信息</span><br><span class="line">git fetch origin &lt;branch-name&gt; 从远程拉去分支代码</span><br><span class="line">git merge 合并代码</span><br><span class="line">git pull &#x3D; git fetch + git merge</span><br><span class="line">git push origin &lt;branch-name&gt; 推送修改</span><br><span class="line">git checkout -b &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt; 本地创建和远程分支对应的分支,名称最好一致</span><br><span class="line">git branch --set-upstream &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt; 建立本地分支和远程分支的关联</span><br></pre></td></tr></table></figure><ul><li>git放弃本地修改，强制更新：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all 下载远程仓库最新内容，不做合并</span><br><span class="line">git reset --hard origin&#x2F;master 把HEAD指向master最新版本</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul><li>创建与合并分支：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev 创建dev分支</span><br><span class="line">git checkout dev 切换至dev分支</span><br><span class="line">git checkout -b dev 创建并切换至dev分支</span><br><span class="line">git branch 查看当前分支</span><br><span class="line">git merge dev 合并dev分支代码至当前分支</span><br><span class="line">git branch -d dev 删除dev分支</span><br></pre></td></tr></table></figure><ul><li>解决冲突：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph 命令可以看到分支合并图</span><br></pre></td></tr></table></figure><ul><li>Bug分支：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash 暂存当前工作区代码</span><br><span class="line">git stash list 查看暂存代码记录</span><br><span class="line">git stash apply 恢复代码至工作区，但不删除暂存内容</span><br><span class="line">git stash drop 删除暂存内容</span><br><span class="line">git stash pop &#x3D; git stash apply + git stash drop 恢复代码至工作区并删除暂存内容</span><br><span class="line">git cherry-pick &lt;commitid&gt; 复制某一次提交代码至当前分支</span><br></pre></td></tr></table></figure><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><ul><li>创建标签：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tagname&gt; 用于新建一个标签，默认为HEAD，也可以指定一个commit id</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;msg&quot; 可以指定标签信息</span><br><span class="line">git tag 查看所有标签</span><br><span class="line">git show &lt;tagname&gt; 查看说明</span><br></pre></td></tr></table></figure><ul><li>操作标签：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt; 删除一个本地标签</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;&lt;tagname&gt; 删除一个远程标签</span><br><span class="line">git push origin &lt;tagname&gt; 推送标签至远程</span><br><span class="line">git push origin --tags 一次性推送全部尚未推送到远程的本地标签</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作区与暂存区&quot;&gt;&lt;a href=&quot;#工作区与暂存区&quot; class=&quot;headerlink&quot; title=&quot;工作区与暂存区&quot;&gt;&lt;/a&gt;工作区与暂存区&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;版本回退：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="tool" scheme="https://marchnineteen.github.io/categories/tool/"/>
    
    
  </entry>
  
  <entry>
    <title>maven-dependence</title>
    <link href="https://marchnineteen.github.io/2019/05/30/tool/maven-dependence/"/>
    <id>https://marchnineteen.github.io/2019/05/30/tool/maven-dependence/</id>
    <published>2019-05-30T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scope参数在dependence中表示依赖的范围。"><a href="#scope参数在dependence中表示依赖的范围。" class="headerlink" title="scope参数在dependence中表示依赖的范围。"></a>scope参数在dependence中表示依赖的范围。</h1><p>首先需要知道，maven在编译项目主代码的时候需要使用一套classpath。例如在编译项目主代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。<br>其次，maven在编译和执行测试的时候会使用另一套classpath，Junit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖<br>范围是test。最后，实际运行maven项目的时候，又会使用一套classpath。</p><p>依赖范围就是用来控制依赖与这三种classpath（编辑classpath、测试classpath、运行classpath）的关系，maven有以下几种依赖范围：</p><p><strong>Compile</strong>：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的maven依赖，对于<strong>编译、测试、运行</strong>三种classpath都有效。<br>典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。</p><p><strong>Test</strong>：测试依赖范围。使用此依赖范围的maven依赖，只对于<strong>测试</strong>的classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是Junit，<br>它只有在编辑测试代码及运行测试的时候才需要。</p><p><strong>Provided</strong>：已提供依赖范围。使用此依赖范围的maven依赖，对于<strong>编译</strong>和<strong>测试</strong>classpath有效，但在运行时无效。典型的例子是servlet-api，<br>编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要maven重复的引入一遍。</p><p><strong>Runtime</strong>：运行时依赖范围。使用该依赖范围的maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译<br>只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述的具体JDBC驱动。</p><p><strong>System</strong>：系统依赖范围。该依赖与三种classpath的关系，<strong>和Provided依赖范围完全一致</strong>。但是，使用System范围的依赖是必须通过systemPath元素显示地指定<br>依赖文件的路径。由于此类依赖不是通过maven仓库解析的，而且往往与本机的系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境<br>变量，如：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;java.sql&lt;/groupId&gt;    &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt;</code></pre><p><strong>Import(maven2.0.9及以上)</strong>：导入依赖范围。该依赖范围不会对3中classpath产生实际影响。    </p><p>上述出import依赖的各种依赖范围3中classpath的关系如下表：</p><table><thead><tr><th align="center">依赖范围(scope)</th><th align="left">编译classpath有效</th><th align="left">测试classpath有效</th><th align="left">运行classpath有效</th><th align="left">例子</th></tr></thead><tbody><tr><td align="center">compile</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">spring-core</td></tr><tr><td align="center">test</td><td align="left">-</td><td align="left">Y</td><td align="left">-</td><td align="left">junit</td></tr><tr><td align="center">provided</td><td align="left">Y</td><td align="left">Y</td><td align="left">-</td><td align="left">servlet-api</td></tr><tr><td align="center">runtime</td><td align="left">-</td><td align="left">Y</td><td align="left">Y</td><td align="left">JDBC驱动</td></tr><tr><td align="center">system</td><td align="left">Y</td><td align="left">Y</td><td align="left">-</td><td align="left">本地的，maven仓库之外的类库文件</td></tr></tbody></table><h1 id="maven传递性依赖"><a href="#maven传递性依赖" class="headerlink" title="maven传递性依赖"></a>maven传递性依赖</h1><p>传递性依赖和依赖范围：</p><p>依赖范围不仅可以控制依赖与三种classpath的关系，还对传递性依赖产生影响。例，account-email对于spring-core的依赖范围是compile，spring-core对于commons-logging<br>的依赖范围的是compile，那么account-email对于commons-logging这一传递依赖的范围也及时compile。假设A依赖与B，B依赖与C，我们说A对于B的依赖是第一直接依赖，<br>B对于C的依赖为第二直接依赖，A对于C是传递性依赖。第一直接依赖的范围是和第二直接依赖的范围决定了传递性依赖的范围，如下表所示，最左边一行表示第一直接依赖范围，<br>最上面一行便是第二直接依赖范围，中间的交叉单元格则便是传递性依赖范围:</p><table><thead><tr><th align="center"></th><th align="left">compile</th><th align="left">test</th><th align="left">provided</th><th align="left">runtime</th></tr></thead><tbody><tr><td align="center">compile</td><td align="left">compile</td><td align="left">-</td><td align="left">-</td><td align="left">runtime</td></tr><tr><td align="center">test</td><td align="left">test</td><td align="left">-</td><td align="left">-</td><td align="left">test</td></tr><tr><td align="center">provided</td><td align="left">provided</td><td align="left">-</td><td align="left">provided</td><td align="left">provided</td></tr><tr><td align="center">runtime</td><td align="left">runtime</td><td align="left">-</td><td align="left">-</td><td align="left">runtime</td></tr></tbody></table><p>仔细观察表格，可以发现规律：当第二直接依赖为compile的时候，传递性依赖的范围与第一直接依赖范围一致；当第二直接依赖范围是test的时候，依赖不会得以传递，<br>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为provided；当第二传递依赖是runtime的时候，<br>传递性依赖的范围与第一直接依赖的范围一致，丹compile例外，此时传递性依赖的范围为runtime。</p><h2 id="maven可选依赖"><a href="#maven可选依赖" class="headerlink" title="maven可选依赖"></a>maven可选依赖</h2><p>使用<optional>元素表示依赖为可选依赖，只会对当前项目产生影响，当其他项目依赖当前项目时，该依赖不会被传递</optional></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;scope参数在dependence中表示依赖的范围。&quot;&gt;&lt;a href=&quot;#scope参数在dependence中表示依赖的范围。&quot; class=&quot;headerlink&quot; title=&quot;scope参数在dependence中表示依赖的范围。&quot;&gt;&lt;/a&gt;scope
      
    
    </summary>
    
    
      <category term="tool" scheme="https://marchnineteen.github.io/categories/tool/"/>
    
    
  </entry>
  
  <entry>
    <title>sql优化</title>
    <link href="https://marchnineteen.github.io/2019/04/12/database/sqlOptimization/"/>
    <id>https://marchnineteen.github.io/2019/04/12/database/sqlOptimization/</id>
    <published>2019-04-12T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLOptimizationTree-SQL优化技术"><a href="#SQLOptimizationTree-SQL优化技术" class="headerlink" title="SQLOptimizationTree SQL优化技术"></a>SQLOptimizationTree SQL优化技术</h1><p><img src="https://i.imgur.com/tPBlMI3.png" alt></p><pre>1) 最左前缀法则2）在索引列上做类型转换，函数变换等操作3）存储引擎不能使用范围条件右边的列作为索引5）!= , > , <不能使用索引 6）b-tree索引 is null不会走,is not null会走,位图索引 null,is null 都会走 7）like 通配符开头不能使用索引 8）尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select * 9）没有使用查询条件，或者查询条件上没有建立索引 10）查询的数量是索引的大部分，30%以上 11）对小表查询 12）其他存储引擎认为使用索引反而查询性能更差时 13）in, in ,not exist 15）在join操作中（需要从多个数据表提取数据时），mysql只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用 16）在order by操作中，mysql只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索 引在加快order by操作方面也没什么作用 17）如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0 1”或“y n”等值，就没有 必要为它创建一个索引 18）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引 19）如果mysql估计使用全表扫描要比使用索引快,则不使用索引 20）尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以 使用 union来查询 21)如果在 where 子句中使用参数，也会导致全表扫描。因为 sql 只有在运行时才会解析局部变 量，但优化程序不能将访问计划的选择到运行时；它必须在编译时进行选择。然而，如果在编译时 简历访问计划，变量的值还是未知的，因而无法作为索引选择的输入项 22)应尽量避免在 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 23)很多时候用 exists 代替 是一个好的选择 25)并不是所有索引对查询都有效，sql是根据表中数据来进行查询优化的，当索引列有大量数据重 复时，sql查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即 使在sex上建了索引也对查询效率起不了作用。 26)尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性 能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而 对于数字型而言只需要比较一次就够了 27)尽可能的使用 varchar nvarchar char nchar ，因为首先变长字段存储空间小，可以 节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些 28)避免频繁创建和删除临时表，以减少系统表资源的消耗 29)尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写 30)尽量避免大事务操作，提高系统并发能力 < pre><p>为排序使用索引</p><p><img src="https://i.imgur.com/msPgvCY.png" alt></p><p><a href="https://blog.csdn.net/tuesdayma/article/details/81783199" target="_blank" rel="noopener">https://blog.csdn.net/tuesdayma/article/details/81783199</a></p><pre>一条sql执行时间过长，如何优化，从哪些方面1）查看sql是否涉及多表的联表查询或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者   合并成零时表。2）涉及联表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合。3）如果以上两种情况都不能操作，非要联表查询，那么考虑对相应的查询条件做索引，加快查询速度。5）针对数量大的表进行历史表分离6）数据库主从分离，读写分离，降低读写针对同一表时的压力7）explain分析SQL语句，查看执行计划，分析索引是否用得上，分析扫描行数。8）查看Mysql执行日志，看看是否有其他方面的问题。</pre><pre>Mysql深度分页      一般刚开始学SQL的时候，会这样写          SELECT * FROM table ORDER BY id LIMIT 1000, 10;       但在数据达到百万级的时候，这样写会慢死          SELECT * FROM table ORDER BY id LIMIT 1000000, 10;       也许耗费几十秒      网上很多优化的方法是这样的          SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;       是的，速度提升到0.x秒了，看样子还行了      可是，还不是完美的！      以下这句才是完美的！           SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010;       比上面那句，还要再快5至10倍      从中我们也能总结出两件事情：         1）limit语句的查询时间与起始记录的位置成正比         2）mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。      2.对limit分页问题的性能优化方法        利用表的覆盖索引来加速分页查询        我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。        因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中        也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。      另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询            SELECT * FROM table WHERE id IN(10000, 100000, 1000000...);       再分享一点      查询字段一较长字符串的时候，表设计时要为该字段多加一个字段,如，存储网址的字段          查询的时候，不要直接查询字符串，效率低下，应该查诡该字串的crc32或md5。      在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何：      这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下：         select id from order limit 800000, 20 0.2秒         相对于查询了所有列的37.44秒，提升了大概100多倍的速度      那么如果我们也要查询所有列，有两种方法，一种是id>=的形式，另一种就是利用join，看下实际情况：         SELECT * FROM order WHERE ID > =(select id from order limit 800000, 1) limit 20      查询时间为0.2秒，简直是一个质的飞跃啊，哈哈      另一种写法         SELECT * FROM order a JOIN (select id from order limit 800000, 20) b ON a.ID = b.id      查询时间也很短</pre><pre>查询锁表信息      当前运行的所有事务      select * from information_schema.innodb_trx      当前出现的锁      select * from information_schema.innodb_locks      锁等待的对应关系      select * from information_schema.innodb_lock_waits  </pre><pre>Mysql一次插入几万条数据处理方式      1）Insert批量插入，调整max_allowed_packet      2) 开启事务，增大innodb_log_buffer_size，增加单事务提交日志量。      3）主键顺序插入，效率更高      5）对要插入的数据进行分组批量插入      INSERT INTO table (column1, column2, ..., column_n) VALUES       (value11, value12, ..., value1n),       (value21, value22, ... value2n), ..., (value_n1, value_n2, ... value_nn)      常用的插入语句如：      INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)              VALUES ('0', 'userid_0', 'content_0', 0);      INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)              VALUES ('1', 'userid_1', 'content_1', 1);      修改成：      INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)       VALUES ('0', 'userid_0', 'content_0', 0), ('1', 'userid_1', 'content_1', 1);      修改后的插入操作能够提高程序的插入效率。这里第二种SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让      日志）减少了，降低日志刷盘的数据量和频率，从而提高效率。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传      输的IO。      数据有序插入。          数据有序的插入是指插入记录在主键上是有序排列，例如datetime是记录的主键：          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)                  VALUES ('1', 'userid_1', 'content_1', 1);          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)                  VALUES ('0', 'userid_0', 'content_0', 0);          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)                  VALUES ('2', 'userid_2', 'content_2',2);          修改成：          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)                  VALUES ('0', 'userid_0', 'content_0', 0);          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)                  VALUES ('1', 'userid_1', 'content_1', 1);          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`)                  VALUES ('2', 'userid_2', 'content_2',2);          由于数据库插入时，需要维护索引数据，无序的记录会增大维护索引的成本。我们可以参照InnoDB使用的B+tree索引，如果每次插          入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等          处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。      从测试结果来看，该优化方法的性能有所提高，但是提高并不是很明显。      SQL语句是有长度限制，在进行数据合并在同一SQL中务必不能超过SQL长度限制，通过max_allowed_packet配置可以修改，默认是1M，      测试时修改为8M。      事务需要控制大小，事务太大可能会影响执行的效率。MySQL有innodb_log_buffer_size配置项，超过这个值会把innodb的数据刷到      磁盘中，这时，效率会有所下降。所以比较好的做法是，在数据达到这个这个值前进行事务提交。</pre><pre>Mysql配置优化提高SQL查询写入性能      提高数据库插入性能的中心思想：              1）尽量将数据一次性写入到Data File              2）减少数据库的checkpoint 操作      innodb_buffer_pool_size            如果用Innodb，那么这是一个重要变量。相对于MyISAM来说，Innodb对于        buffer size更敏感。MySIAM可能对于大数据量使用默认的key_buffer_size也还好，        但Innodb在大数据量时用默认值就感觉在爬了。 Innodb的缓冲池会缓存数据和索引，所        以不需要给系统的缓存留空间，如果只用Innodb，可以把这个值设为内存的70%-80%。        和 key_buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提        高内存的使用率。      innodb_log_file_size            此配置项作用设定innodb 数据库引擎UNDO日志的大小；从而减少数据库checkpoint        操作。           对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢        复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。      innodb_log_buffer_size            此配置项作用设定innodb 数据库引擎写日志缓存区；将此缓存段增大可以减少数据库写        数据文件次数           默认值对于多数中等写操作和事务短的运用都是可以的。如 果经常做更新或者使用了        很多blob数据，应该增大这个值。但太大了也是浪费内存，因为1秒钟总会 flush（这个词        的中文怎么说呢？）一次，所以不需要设到超过1秒的需求。8M-16M一般应该够了。小的运用        可以设更小一点。      innodb_flush_log_at_trx_commit            0: Write the log buffer to the log file and flush the log file               every second, but do nothing at transaction commit.            1：the log buffer is written out to the log file at each               transaction commit and the flush to disk operation is performed               on the log file            2：the log buffer is written out to the file at each commit, but               the flush to disk operation is not performed on it            抱怨Innodb比MyISAM慢 100倍？那么你大概是忘了调整这个值。默认值1的意思是每一        次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用        电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM        表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到        硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即        使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。      innodb_autoextend_increment 配置由于默认8M 调整到 128M           此配置项作用主要是当tablespace 空间已经满了后，需要MySQL系统需要自动扩展多        少空间，每次tablespace 扩展都会让各个SQL 处于等待状态。增加自动扩展Size可以减        少tablespace自动扩展次数。      提高数据库插入性能中心思想：           1、尽量使数据库一次性写入Data File           2、减少数据库的checkpoint 操作           3、程序上尽量缓冲数据，进行批量式插入与提交           4、减少系统的IO冲突      提高数据库读取速度</pre><pre>Mysql表查询优化经验</pre><pre>Using index       查询的列被索引覆盖，并且where筛选条件是索引的是前导列      Using where Using index        1:查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的不是前导列，          Extra中为Using where; Using index，意味着无法直接通过索引查找来查询到符          合条件的数据        2:查询的列被索引覆盖，并且where筛选条件是索引列前导列的一个范围，同样意味着无法          直接通过索引查找查询到符合条件的数据     NULL（既没有Using index，也没有Using where Using index，也没有using where）        1，查询的列未被索引覆盖，并且where筛选条件是索引的前导列，　　     意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用         到了索引，也不是完全没用到索引，Extra中为NULL(没有信息)     Using where        1，查询的列未被索引覆盖，where筛选条件非索引的前导列，Extra中为Using where        2，查询的列未被索引覆盖，where筛选条件非索引列，Extra中为Using where        using where 意味着通过索引或者表扫描的方式进程where条件的过滤，　　    反过来说，也就是没有可用的索引查找，当然这里也要考虑索引扫描+回表与表扫描的代价。　　    这里的type都是all，说明MySQL认为全表扫描是一种比较低的代价。     Using index condition        1，-- 查询的列不全在索引中，where条件中是一个前导列的范围        2，查询列不完全被索引覆盖，查询条件完全可以使用到索引（进行索引查找）</pre><p><img src="https://i.imgur.com/UCgL2Vh.png" alt></p><pre>Explain详细解析      table：表名      type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、            eq_reg、ref、range、index和ALL      possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关            的域从WHERE语句中选择一个合适的语句      key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足            的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使            用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引      key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好      ref：显示索引的哪一列被使用了，如果可能的话，是一个常数      rows：MYSQL认为必须检查的用来返回请求数据的行数      extra列返回的描述的意义           Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了           Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不                       再搜索了           Range checked for each Record（index map:#）:没有找到理想的索引，因此对               于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中               返回行。这是使用索引的最慢的连接之一           Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来               发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行               的行指针来排序全部行           Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返                        回的，这发生在对表的全部的请求列都是同一个索引的部分的时候           Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时                 表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上           Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果                不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有                问题不同连接类型的解释（按照效率高低的顺序排序）           system 表只有一行：system表。这是const连接类型的特殊情况           const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因              为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待           eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取                  一个记录，它在查询使用了索引为主键或惟一键的全部时使用           ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分             （比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从              表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好           range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况 index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比all更好，因为 索引一般小于表数据） all:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免 < pre><pre>子查询 联合join查询效率</pre></查找东西时发生的情况></pre></不能使用索引></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLOptimizationTree-SQL优化技术&quot;&gt;&lt;a href=&quot;#SQLOptimizationTree-SQL优化技术&quot; class=&quot;headerlink&quot; title=&quot;SQLOptimizationTree SQL优化技术&quot;&gt;&lt;/a&gt;SQLOp
      
    
    </summary>
    
    
      <category term="database" scheme="https://marchnineteen.github.io/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库系统原理(转载)</title>
    <link href="https://marchnineteen.github.io/2019/04/12/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://marchnineteen.github.io/2019/04/12/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2019-04-12T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">原文</a></p><ul><li><a href="#一事务">一、事务</a><ul><li><a href="#概念">概念</a></li><li><a href="#acid">ACID</a></li><li><a href="#autocommit">AUTOCOMMIT</a></li></ul></li><li><a href="#二并发一致性问题">二、并发一致性问题</a><ul><li><a href="#丢失修改">丢失修改</a></li><li><a href="#读脏数据">读脏数据</a></li><li><a href="#不可重复读">不可重复读</a></li><li><a href="#幻影读">幻影读</a></li></ul></li><li><a href="#三封锁">三、封锁</a><ul><li><a href="#封锁粒度">封锁粒度</a></li><li><a href="#封锁类型">封锁类型</a></li><li><a href="#封锁协议">封锁协议</a></li><li><a href="#mysql-隐式与显示锁定">MySQL 隐式与显示锁定</a></li></ul></li><li><a href="#四隔离级别">四、隔离级别</a><ul><li><a href="#未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</a></li><li><a href="#提交读read-committed">提交读（READ COMMITTED）</a></li><li><a href="#可重复读repeatable-read">可重复读（REPEATABLE READ）</a></li><li><a href="#可串行化serializable">可串行化（SERIALIZABLE）</a></li></ul></li><li><a href="#五多版本并发控制">五、多版本并发控制</a><ul><li><a href="#版本号">版本号</a></li><li><a href="#隐藏的列">隐藏的列</a></li><li><a href="#undo-日志">Undo 日志</a></li><li><a href="#实现过程">实现过程</a></li><li><a href="#快照读与当前读">快照读与当前读</a></li></ul></li><li><a href="#六next-key-locks">六、Next-Key Locks</a><ul><li><a href="#record-locks">Record Locks</a></li><li><a href="#gap-locks">Gap Locks</a></li><li><a href="#next-key-locks">Next-Key Locks</a></li></ul></li><li><a href="#七关系数据库设计理论">七、关系数据库设计理论</a><ul><li><a href="#函数依赖">函数依赖</a></li><li><a href="#异常">异常</a></li><li><a href="#范式">范式</a></li></ul></li><li><a href="#八er-图">八、ER 图</a><ul><li><a href="#实体的三种联系">实体的三种联系</a></li><li><a href="#表示出现多次的关系">表示出现多次的关系</a></li><li><a href="#联系的多向性">联系的多向性</a></li><li><a href="#表示子类">表示子类</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f74144be-857a-40cd-8ec7-87626ef4e20b.png"> </div><br><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>使用重做日志来保证持久性。</p><hr><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><div align="center"> <img src="https://github.com//CyC2018/CS-Notes/raw/master/notes/pics/417bc315-4409-48c6-83e0-59e8d405429e.jpg" width="700"> </div><br><h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/75184b58-c627-4edc-8dcf-605762ebb733.png" width="350"> </div><br><h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/af0e94d9-502d-4531-938f-d46dd29de52d.png" width="400"> </div><br><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/66ae164c-ad47-4905-895e-51fe38ce797a.png" width="400"> </div><br><h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png" width="400"> </div><br><hr><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="300"> </div><br><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：</p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">S</td><td align="center">×</td><td align="center">√</td></tr></tbody></table><h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">IX</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">S</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">IS</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong> </p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><table><thead><tr><th align="center">T<sub>1</sub></th><th align="center">T<sub>2</sub></th></tr></thead><tbody><tr><td align="center">lock-x(A)</td><td align="center"></td></tr><tr><td align="center">read A=20</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">lock-x(A)</td></tr><tr><td align="center"></td><td align="center">wait</td></tr><tr><td align="center">write A=19</td><td align="center">.</td></tr><tr><td align="center">commit</td><td align="center">.</td></tr><tr><td align="center">unlock-x(A)</td><td align="center">.</td></tr><tr><td align="center"></td><td align="center">obtain</td></tr><tr><td align="center"></td><td align="center">read A=19</td></tr><tr><td align="center"></td><td align="center">write A=21</td></tr><tr><td align="center"></td><td align="center">commit</td></tr><tr><td align="center"></td><td align="center">unlock-x(A)</td></tr></tbody></table><p><strong>二级封锁协议</strong> </p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><table><thead><tr><th align="center">T<sub>1</sub></th><th align="center">T<sub>2</sub></th></tr></thead><tbody><tr><td align="center">lock-x(A)</td><td align="center"></td></tr><tr><td align="center">read A=20</td><td align="center"></td></tr><tr><td align="center">write A=19</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">lock-s(A)</td></tr><tr><td align="center"></td><td align="center">wait</td></tr><tr><td align="center">rollback</td><td align="center">.</td></tr><tr><td align="center">A=20</td><td align="center">.</td></tr><tr><td align="center">unlock-x(A)</td><td align="center">.</td></tr><tr><td align="center"></td><td align="center">obtain</td></tr><tr><td align="center"></td><td align="center">read A=20</td></tr><tr><td align="center"></td><td align="center">unlock-s(A)</td></tr><tr><td align="center"></td><td align="center">commit</td></tr></tbody></table><p><strong>三级封锁协议</strong> </p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><table><thead><tr><th align="center">T<sub>1</sub></th><th align="center">T<sub>2</sub></th></tr></thead><tbody><tr><td align="center">lock-s(A)</td><td align="center"></td></tr><tr><td align="center">read A=20</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">lock-x(A)</td></tr><tr><td align="center"></td><td align="center">wait</td></tr><tr><td align="center">read A=20</td><td align="center">.</td></tr><tr><td align="center">commit</td><td align="center">.</td></tr><tr><td align="center">unlock-s(A)</td><td align="center">.</td></tr><tr><td align="center"></td><td align="center">obtain</td></tr><tr><td align="center"></td><td align="center">read A=20</td></tr><tr><td align="center"></td><td align="center">write A=19</td></tr><tr><td align="center"></td><td align="center">commit</td></tr><tr><td align="center"></td><td align="center">unlock-X(A)</td></tr></tbody></table><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th><th align="center">加锁读</th></tr></thead><tbody><tr><td align="center">未提交读</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">提交读</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">可串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr></tbody></table><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><h2 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" width> </div><br><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" width="300"> </div><br><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><font size="4"> <strong>分解前</strong> </font><br></p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><font size="4"> <strong>分解后</strong> </font><br></p><p>关系-1</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th align="center">Sno</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt;  Grade</li></ul><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th align="center">Sdept</th><th align="center">Mname</th></tr></thead><tbody><tr><td align="center">学院-1</td><td align="center">院长-1</td></tr><tr><td align="center">学院-2</td><td align="center">院长-2</td></tr></tbody></table><h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg" width> </div><br><h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg" width> </div><br><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png" width> </div><br><p>一般只使用二元联系，可以把多元联系转换为二元联系。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png" width> </div><br><h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg" width> </div><br><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li><li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li><li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li><li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li><li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li><li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li><li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li><li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li><li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md&quot; t
      
    
    </summary>
    
    
      <category term="database" scheme="https://marchnineteen.github.io/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>java线程解析</title>
    <link href="https://marchnineteen.github.io/2019/03/02/java/javase/thread/"/>
    <id>https://marchnineteen.github.io/2019/03/02/java/javase/thread/</id>
    <published>2019-03-02T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h1><p>并行与并发：</p><ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是<strong>真正的同时</strong>。 </li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li><li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。</li><li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</li><li>volatile：多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。<br>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</li></ul><p><img src="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/resources/static/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%8E%9F%E5%9E%8B.jpg" alt="多线程内存原型"> </p><h1 id="线程状态-amp-状态切换"><a href="#线程状态-amp-状态切换" class="headerlink" title="线程状态&amp;状态切换"></a>线程状态&amp;状态切换</h1><p><img src="http://upload-images.jianshu.io/upload_images/4942449-8f4ad7b6ac7009c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程状态转换"> </p><h2 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h2><ul><li>wait()：当前线程放弃对象锁，使该线程处于<strong>等待池</strong>(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到<strong>锁定池</strong>(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）。</li><li>notify():从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。</li><li>notifyAll(): notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。</li></ul><p>注意点：<a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/java/com/wyb/thread/base/synchronize" target="_blank" rel="noopener">源码</a></p><ul><li><strong>wait()当前线程立即释放对象锁，notify() notifyAll() 之后 才会执行剩下代码</strong></li><li><strong>notify() notifyAll() 本身不会释放锁，仅仅是通知，当同步块执行完毕之后才会释放锁</strong>。</li></ul><h2 id="Thread线程方法："><a href="#Thread线程方法：" class="headerlink" title="Thread线程方法："></a>Thread线程方法：</h2><ul><li>yield():正在执行的线程把运行机会交给线程池中拥有相同优先级的线程，无法保证迅速转换，运行状态转到可运行状态.</li><li>join():使得一个线程在另一个线程结束后再执行。在一个线程中调用other.join(),将等待other执行完后才继续本线程。</li><li>sleep():不会释放对象锁，暂停一段时间。</li><li>interrupt()：后两个函数皆可以被打断。</li></ul><p>使用condition控制线程通信：</p><ul><li>await(),类似wait()</li><li>signal() 类似notify</li><li>signalAll()类似notifyAll</li></ul><h1 id="高级多线程控制类："><a href="#高级多线程控制类：" class="headerlink" title="高级多线程控制类："></a>高级多线程控制类：</h1><h2 id="1-ThreadLocal类"><a href="#1-ThreadLocal类" class="headerlink" title="1.ThreadLocal类:"></a>1.ThreadLocal类:</h2><h2 id="2-原子类（AtomicInteger、AtomicBoolean……）"><a href="#2-原子类（AtomicInteger、AtomicBoolean……）" class="headerlink" title="2.原子类（AtomicInteger、AtomicBoolean……）"></a>2.原子类（AtomicInteger、AtomicBoolean……）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cas方法</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">&#x2F;&#x2F;使用unsafe的native方法，实现高效的硬件级别CAS</span><br><span class="line">return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Lock类"><a href="#3-Lock类" class="headerlink" title="3.Lock类　"></a>3.Lock类　</h2><ul><li>Condition</li><li>ReentrantLock</li></ul><p><img src="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/resources/static/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E8%8E%B7%E5%8F%96%E9%94%81%E8%BF%87%E7%A8%8B.jpg" alt="非公平锁获取锁过程"></p><p>公平锁和非公平锁不同之处在于，公平锁在获取锁的时候，不会先去检查state状态，而是直接执行aqcuire(1),即直接进入队列</p><p>so:由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p><ul><li>ReentrantReadWriteLock.ReadLock</li><li>ReentrantReadWriteLock.WriteLock</li></ul><h2 id="4-容器类"><a href="#4-容器类" class="headerlink" title="4.容器类"></a>4.容器类</h2><ul><li>BlockingQueue</li><li>ConcurrentHashMap</li></ul><h2 id="5-管理类"><a href="#5-管理类" class="headerlink" title="5.管理类"></a>5.管理类</h2><ul><li>ThreadPoolExecutor</li></ul><p>线程池构成方法参数：</p><p>1.指定核心线程数量</p><p>2.</p><p>队列排队策略：</p><p>同步移交：不会放到队列中，而是等待线程执行它。如果当前线程没有执行，很可能会新开一个线程执行。</p><p>核心线程满了，接下来进队列，队列也满了，创建新线程，直到达到最大线程数，之后再超出，会进入拒绝rejectedExecution</p><ul><li>JMX框架下的系统级管理类 ThreadMXBean</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一些概念：&quot;&gt;&lt;a href=&quot;#一些概念：&quot; class=&quot;headerlink&quot; title=&quot;一些概念：&quot;&gt;&lt;/a&gt;一些概念：&lt;/h1&gt;&lt;p&gt;并行与并发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是&lt;strong&gt;真正
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="https://marchnineteen.github.io/categories/JavaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式：责任链模式</title>
    <link href="https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/chainOfResponsibility/"/>
    <id>https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/chainOfResponsibility/</id>
    <published>2019-01-24T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>定义个抽象类，依赖一个本身对象，每个继承类，即可传入其它的继承类实现对象链。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义处理器抽象类 依赖一个本身对象，通过构造器传入，拥有一个处理请求的抽象方法 </p><pre><code>protected Handler successor;    public Handler(Handler successor) {        this.successor = successor;    }    protected abstract void handleRequest(Request request);</code></pre><p>   请求参数类</p><pre><code>public class Request {    private RequestType type;    private String name;    public Request(RequestType type, String name) {        this.type = type;        this.name = name;    }    public RequestType getType() {        return type;    }    public String getName() {        return name;    }}</code></pre><p>   请求类型枚举类 不同的请求类型 调用不同的处理器</p><pre><code>public enum RequestType {    TYPE1, TYPE2, TYPE3} </code></pre><p>   定义处理器类1继承抽象类处理类型为TYPE1的请求</p><pre><code>public class ConcreteHandler1 extends Handler {   public ConcreteHandler1(Handler successor) {       super(successor);   }   @Override   protected void handleRequest(Request request) {       if (RequestType.TYPE1 == request.getType()) {           System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);           return;       }       if (successor != null) {           successor.handleRequest(request);       }   }}</code></pre><p>   定义处理器类2继承抽象类处理类型为TYPE2的请求</p><pre><code>public class ConcreteHandler2 extends Handler {   public ConcreteHandler2(Handler successor) {       super(successor);   }   @Override   protected void handleRequest(Request request) {       if (request.getType() == RequestType.TYPE2) {           System.out.println(request.getName() + &quot; is handle by ConcreteHandler2&quot;);           return;       }       if (successor != null) {           successor.handleRequest(request);       }   }}</code></pre><p>   测试：</p><pre><code>public class Client {   public static void main(String[] args) {       Handler handler1 = new ConcreteHandler1(null);       Handler handler2 = new ConcreteHandler2(handler1);       Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);       handler2.handleRequest(request1);       Request request2 = new Request(RequestType.TYPE2, &quot;request2&quot;);       handler2.handleRequest(request2);       Handler handler3 = new ConcreteHandler3(handler2);       Request request3 = new Request(RequestType.TYPE3, &quot;request3&quot;);       handler3.handleRequest(request1);   }}</code></pre><p>   输出：</p><pre><code>request1 is handle by ConcreteHandler1request2 is handle by ConcreteHandler2</code></pre><p>   再定义一个定义处理器类3继承抽象类处理类型为TYPE3的请求</p><pre><code>public class ConcreteHandler3 extends Handler {   public ConcreteHandler3(Handler successor) {       super(successor);   }   @Override   protected void handleRequest(Request request) {       if (RequestType.TYPE3 == request.getType()) {           System.out.println(request.getName() + &quot; is handle by ConcreteHandler3&quot;);           return;       }       if (successor != null) {           successor.handleRequest(request);       }   }}</code></pre><p>   测试：使用handler3处理request1请求</p><pre><code>public class Client {    public static void main(String[] args) {        Handler handler1 = new ConcreteHandler1(null);        Handler handler2 = new ConcreteHandler2(handler1);        Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);        Handler handler3 = new ConcreteHandler3(handler2);        Request request3 = new Request(RequestType.TYPE3, &quot;request3&quot;);        handler3.handleRequest(request1);    }}</code></pre><p>   输出：最外层的Handler即调用所有类型的处理请求</p><pre><code>request1 is handle by ConcreteHandler1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义-目的&quot;&gt;&lt;a href=&quot;#定义-目的&quot; class=&quot;headerlink&quot; title=&quot;定义(目的)&quot;&gt;&lt;/a&gt;定义(目的)&lt;/h1&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该
      
    
    </summary>
    
    
      <category term="java-design-patterns" scheme="https://marchnineteen.github.io/categories/java-design-patterns/"/>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式：观察者模式</title>
    <link href="https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/observer/"/>
    <id>https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/observer/</id>
    <published>2019-01-24T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>主题依赖了观察者的一个集合，观察者依赖了一个主题，生成一个观察者需要在主题进行注册，主题更新后对每个观察者进行推送</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义主题接口，拥有对观察者的操作方法</p><pre><code>public interface Subject {    // 注册观察者    public void registerObserver(Observer observer);    // 移除观察者    public void removeObserver(Observer observer);    // 提醒观察者    public void notifyObserver();}</code></pre><p>   定义一个观察者接口，提供一个操作接口，方便主题更新时对观察者进行操作</p><pre><code>public interface Observer {    void update(float temp, float humidity, float pressure);}</code></pre><p>   定义主题接口实现类，依赖了一个观察者集合，当对主题进行更新时，循环通知各个观察者</p><pre><code>public class WeatherSubject implements Subject {    private List&lt;Observer&gt; observers;    private float temperature;    private float humidity;    private float pressure;    public WeatherSubject() {        observers = new ArrayList&lt;&gt;();    }    public void setMeasurements(float temperature, float humidity, float pressure) {        this.temperature = temperature;        this.humidity = humidity;        this.pressure = pressure;        notifyObserver();    }    @Override    public void registerObserver(Observer observer) {        observers.add(observer);    }    @Override    public void removeObserver(Observer observer) {        int i = observers.indexOf(observer);        if (i &gt;= 0) {            observers.remove(i);        }    }    @Override    public void notifyObserver() {        for (Observer o : observers) {            o.update(temperature, humidity, pressure);        }    }}</code></pre><p>   定义观察者实现类，每个观察者通过构造方法传入它所订阅的主题，并在主题中注册该观察者</p><pre><code>public class StatisticsDisplay implements Observer {    public StatisticsDisplay(Subject weatherData) {        weatherData.registerObserver(this);    }    @Override    public void update(float temp, float humidity, float pressure) {        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    }}</code></pre><p>   定义另一个观察者实现类</p><pre><code>public class CurrentConditionsDisplay implements Observer {    public CurrentConditionsDisplay(Subject weatherData) {        weatherData.registerObserver(this);    }    @Override    public void update(float temp, float humidity, float pressure) {        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    }}</code></pre><p>   测试：</p><pre><code>public class Client {    public static void main(String[] args) {        WeatherSubject subject = new WeatherSubject();        Observer statis = new StatisticsDisplay(subject);        Observer current = new CurrentConditionsDisplay(subject);        subject.setMeasurements(22f, 29f, 100f);    }}</code></pre><p>   输出：</p><pre><code>StatisticsDisplay.update: 22.0 29.0 100.0CurrentConditionsDisplay.update: 22.0 29.0 100.0</code></pre><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><p>第一眼看到这个模式就感觉这不就是java的监听器嘛，其实监听器就是通过这种模式实现的。</p><ul><li>java.util.Observer</li><li>java.util.EventListener</li><li>javax.servlet.http.HttpSessionBindingListener</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义-目的&quot;&gt;&lt;a href=&quot;#定义-目的&quot; class=&quot;headerlink&quot; title=&quot;定义(目的)&quot;&gt;&lt;/a&gt;定义(目的)&lt;/h1&gt;&lt;p&gt;定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。&lt;/p&gt;
&lt;p&gt;主题（
      
    
    </summary>
    
    
      <category term="java-design-patterns" scheme="https://marchnineteen.github.io/categories/java-design-patterns/"/>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式：外观模式</title>
    <link href="https://marchnineteen.github.io/2019/01/24/java/java-design/structure/facade/"/>
    <id>https://marchnineteen.github.io/2019/01/24/java/java-design/structure/facade/</id>
    <published>2019-01-24T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>定义一个外观对象，在内部进行功能的封装，功能具体是在都在外观类的内部，其它方法要使用该功能<br>调用外观对象的方法即可。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义一个电影播放系统，方法代表需要功能所需步骤</p><pre><code>public class SubSystem {    public void turnOnTV() {        System.out.println(&quot;turnOnTV()&quot;);    }    public void setCD(String cd) {        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);    }    public void starWatching() {        System.out.println(&quot;starWatching()&quot;);    }}</code></pre><p>   定义一个外观类，封装了看电影的三步骤，客户端只需调用外观类的方法即可实现功能</p><pre><code>public class Facade {    private SubSystem subSystem = new SubSystem();    public void watchMovie(String name) {        subSystem.turnOnTV();        subSystem.setCD(name);        subSystem.starWatching();    }}</code></pre><p>   测试：</p><pre><code>public class Client {    public static void main(String[] args) {        Facade facade = new Facade();        facade.watchMovie(&quot;家有喜事&quot;);    }}</code></pre><p>   测试：</p><pre><code>turnOnTV()setCD( 家有喜事 )starWatching()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义-目的&quot;&gt;&lt;a href=&quot;#定义-目的&quot; class=&quot;headerlink&quot; title=&quot;定义(目的)&quot;&gt;&lt;/a&gt;定义(目的)&lt;/h1&gt;&lt;p&gt;提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。&lt;/p&gt;
&lt;h1 id=&quot;实现原理&quot;&gt;
      
    
    </summary>
    
    
      <category term="java-design-patterns" scheme="https://marchnineteen.github.io/categories/java-design-patterns/"/>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式：策略模式</title>
    <link href="https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/strategy/"/>
    <id>https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/strategy/</id>
    <published>2019-01-24T00:00:00.000Z</published>
    <updated>2021-07-01T08:01:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>把对象的功能实现定义成一个接口，对象中依赖一个功能接口，通过改变接口的实现，来达到不同的功能。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义功能接口</p><pre><code>public interface CallBehavior {   // 叫，不同动物叫声不同   void call();}</code></pre><p>   功能接口实现</p><pre><code>public class Quack implements CallBehavior {    @Override    public void call() {        System.out.println(&quot;鸭子叫!&quot;);    }}public class Squeak implements CallBehavior {   @Override   public void call() {       System.out.println(&quot;鸡叫k!&quot;);   }}</code></pre><p>   定义对象类，并依赖功能接口，通过改变接口的具体实现达到不同的功能</p><pre><code>public class Duck {    private CallBehavior behavior;    public void performQuack() {        if (behavior != null) {            behavior.call();        }    }    public void setQuackBehavior(CallBehavior behavior) {        this.behavior = behavior;    }}</code></pre><p>   测试：</p><pre><code>public class Client {    public static void main(String[] args) {        Duck duck = new Duck();        CallBehavior quack = new Quack();        duck.setQuackBehavior(quack);        duck.performQuack();        CallBehavior squeak = new Squeak();        duck.setQuackBehavior(squeak);        duck.performQuack();    }}</code></pre><p>   输出：</p><pre><code>鸭子叫!鸡叫k!</code></pre><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><ul><li>java.util.Comparator#compare()</li><li>javax.servlet.http.HttpServlet</li><li>javax.servlet.Filter#doFilter()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义-目的&quot;&gt;&lt;a href=&quot;#定义-目的&quot; class=&quot;headerlink&quot; title=&quot;定义(目的)&quot;&gt;&lt;/a&gt;定义(目的)&lt;/h1&gt;&lt;p&gt;定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="java-design-patterns" scheme="https://marchnineteen.github.io/categories/java-design-patterns/"/>
    
    
  </entry>
  
</feed>
